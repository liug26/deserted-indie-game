extends Node2D

"""
Game scene, instantiated by start.tscn, is where the game runs

Scene Structure:
	LevelGen: map generation (terrain, enemy, props, tunnel)
		and difficulty adjustments
	Navigation: contains utility functions related to locating
		and navigating, stores the A* algorithm
	Instances: stores instances (enemy and props) generated by LevelGen
	Tunnel: the tunnel always stays in the middle of the top edge
		of the map, gets generated when player acquires game_pass,
		leads player to the end gate resulting in two endings
		(this is known as tunnel opening). also notice that Tunnel
		is located between Instances & Player so that the canvas
		masks (ShadeLow, ShadeTunnel, ShadeHigh) can cover the map,
		enemies and props but not the player.
	Player: the player body, stores player status variables and
		functions
	Canvas Modulate: a dark mask covering the entire UI screen
		allows Light2Ds to light up dark places
	UI: canvas layer module, controls all interfaces displaying
		directly to the user (doesn't exist on map)
	Audio: stores all AudioStreamPlayer (global sounds), controls
		all audio sources in the scene

Affiliated scenes:
Instance scenes (under LevelGen):
	Enemy: chi.tscn, mei.tscn, wang.tscn, liang.tscn, gui.tscn
	Props: coin.tscn, ice.tscn, vision_buff.tscn
UI scenes (under UI):
	game_over.tscn: the animation played when game is over
	item.tscn: displays buyable items on the bottom left corner
	status.tscn: displays status icons on the top left corner
Utility scenes:
	buff.tscn: under Player, gives player an effect for a duration

Game timeline:
	1. randomly set difficulty-influenced parameters in LevelGen
	2. random level generation by LevelGen given difficulty,
		set the second set of level-related parameters
	3. initialize UI with the two sets of LevelGen parameters
	4. freeze game, allow guide to play, displaying what enemies
		are spawned and how many coins to win the game
	5. unfreeze game, game is playable
The following are event-dependent, so are not listed chronologically:
	Event chains:
	1. enemy collides with player -> Player.update_health() -> UI.update_health()
		& audio
	2. coin collides with player -> audio & Player.update_coin() ->
		UI.update_coin() -> displays buyable items
	3. item clicked -> UI.on_item_bought() -> audio & Player.add_buff()
		-> buff.tscn
		if vital items are bought (resurrection & game pass):
		buff.tscn -> Game.on_vital_items_acquired() ->
		LevelGen.update_map()
	4. prop (except coin) collides with player -> audio & Player.add_buff()
		-> buff.tscn
	5. player's health < 0 -> game.on_game_over() -> global freeze
		-> game_over.tscn -> audio & main menu/restart
	6. end gate collides with player -> game.on_game_over() ->
		global freeze -> game_over.tscn -> audio & main menu
	7. esc pressed -> global freeze -> resume/main menu/restart
	8. resume pressed -> global unfreeze
	9. main menu -> Start.on_game_over() -> free self
	10. try again -> Start.on_game_over() -> free self
Ending requirements:
	1. ending (-1) requires Player.resurrection=2 and Player.health<0
		game over scene will display "you didn't succeed" and the try
		again button, accompanied by the "fish_head" audio, signifying
		laughter of the enemies
	2. ending (0) requires Player.resurrection!=2 and Player.health<0
		game over scene will display "you didn't succeed" and the try
		again button and a strange-sounding audio
	3. ending (1) requires Player.resurrection!=1 and Player.game_pass=1
		and player reaching the end gate. note that if player dies
		on way to the end gate it does not count. game over scene will
		display "you escaped" and only the main menu button, accompanied
		by a cheerful audio
	4. ending (2) requires Player.resurrection=1 and Player.game_pass=1
		and player reaching the end gate. when the player acquires both
		unused resurrection and game pass, instance clearing will be
		triggered. this will clear all enemies and props on the map,
		essentially preventing player from dying. so very likely the player
		will reach the end gate. game over scene will display "spirits are
		fared away" and only the main menu button, accompanied by a slightly
		more cheerful audio
"""
# game node: controls starting, ending, freezing of the game

# global freeze freezes (stop movements and updates) all nodes
# passes a bool = true: freeze, = false: unfreeze
signal global_freeze

onready var start = get_node("/root/Start")
# indicates if game is over
var game_over = false


# turns on or off debug mode, called at the beginning of Game.start_game()
# you can comment on any of the lines to customize
func _debug_mode(on):
	if on:
		# disable CanvasModulate, make everything appear brighter
		$CanvasModulate.visible = false
		# activate God view camera, views the entire map
		$LevelGen/GodView.current = true
		# player can take damage and use resurrection, but cannot die
		$Player.immortal = true
		# enable the Line2D displaying enemy's traveling path
		$LevelGen.display_enemy_path = true
		# make buyable items cost 0 coins
		$UI.zero_price_items = true
		# give player maximum coins (this won't actually give player 999 coins)
		$Player.coins = 999


# called by start.tscn, generate level and start game with given difficulty
func start_game(mode):
	# set up parameters if in debug mode
	_debug_mode(true)
	# first generate level
	$LevelGen.set_difficulty(mode)
	$LevelGen.initialize_level()
	# initialize ui according to level parameters generated
	$UI.initialize()
	# freeze the game so that UI/Guide can play before game starts
	emit_signal("global_freeze", true)


# called by Player when health < 0, or Tunnel when Player enters end gate
# if over = false: player dies, over = true: player reaches end gate
func on_game_over(over):
	emit_signal("global_freeze", true)
	game_over = true
	# instantiate game over scene
	var scene = load("res://scenes/game_over/game_over.tscn")
	var gameover = scene.instance()
	if over:
		if $Player.resurrection == 1:
			gameover.initialize(2)
		else:
			gameover.initialize(1)
	else:
		if $Player.resurrection == 2:
			gameover.initialize(-1)
		else:
			gameover.initialize(0)
	$UI.add_child(gameover)



# when player enters Tunnel/EndGate, results in game over
func _on_end_gate_body_entered(body):
	if body.name == "Player":
		on_game_over(true)


# called by buff.tscn or Player, when player buys resurrection or game pass
# and when player uses resurrection
func on_vital_items_acquired():
	# check if conditions allow for tunnel opening/instance clearing
	$LevelGen.update_map()
	# give player a prompt on the bottom right if conditions allow
	if ($Player.resurrection == 0 or $Player.resurrection == 2) and $Player.game_pass == 1:
		# when player buys game pass. note that resurrection=2 and
		# game_pass=1 has to be called from buying game pass, because
		# you cannot use resurrection when resurrection=1 and game_pass=1
		# as all instances including enemies are freed
		$UI.set_rich_text("[right]an entrance opens up [fade start=-4 length=14]somewhere[/fade][/right]")
	elif $Player.resurrection == 1 and $Player.game_pass == 1:
		# when player acquires both resurrection and game pass
		$UI.set_rich_text("[right]i feel[shake rate=7 level=12]... [/shake] peace[/right]")
		$Audio.set_all_volume(0)  # mutes all audio source
	elif $Player.resurrection == 1 and $Player.game_pass == 0:
		# when player buys resurrection, does not have game pass
		$UI.set_rich_text("[right]might save your [color=#FF5733]life[/color][/right]")


# called by UI/Esc/Resume
func _on_resume_pressed():
	$UI/Esc.visible = false
	emit_signal("global_freeze", false)


# called by game_over.tscn or UI/Esc/MainMenu
func on_main_menu():
	start.on_game_ends()
	queue_free()


# called by game_over.tscn or UI/Esc/Restart
func on_restart_game():
	# the argument mode lets start recreate a game with the same difficulty
	start.on_game_ends($LevelGen.mode)
	queue_free()


# UI/Guide/Timer times out, when guide is shown and games can unfreeze to start
func _on_Guide_Timer_timeout():
	"""
	Because UI/Guide/Timer unfreezes global freeze, global freeze
	does not stop this timer. If player presses escape during guide
	and does not resume before timer timeout, global freeze will be
	removed and game will process while escape page is still being
	shown. This is unwanted. So this additional if line that if esc
	is being shown when timer timeout, do not remove global freeze
	but instead let esc's resume button remove the global freeze
	instead. 
	"""
	if not $UI/Esc.visible:
		emit_signal("global_freeze", false)


# detects escape pressing
func _input(event):
	# if game is over and game_over.tscn is animating, disable escaping
	if event.is_action_pressed("ui_cancel") and not game_over:
		$UI/Esc.visible = true
		emit_signal("global_freeze", true)
